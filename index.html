<html>

<head>
  <title>CoastSat transects (including NZ)</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.glify@3.3.0/dist/glify-browser.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/spin.js/2.3.2/spin.min.js"></script>
  <script src="https://unpkg.com/leaflet-spin@1.1.0/leaflet.spin.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"
    integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/leaflet-geosearch@latest/dist/bundle.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-geosearch@latest/assets/css/leaflet.css">
  <script src="https://unpkg.com/leaflet-providers@1.3.0/leaflet-providers.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"
    integrity="sha512-zInFF17qBFVvvvFpIfeBzo7Tj7+rQxLeTJDmbxjBz5/zIr89YVbTNelNhdTT+/DCrxoVzBeUPVFJsczKbB7sew=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-LT8M0QZJES"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-LT8M0QZJES');
  </script>
  
  <style>
      body,
      html,
      #map {
          width: 100%;
          height: 100%;
          margin: 0;
          padding: 0;
      }

      .legend {
          color: white;
          padding: 10px;
          background-color: rgba(0, 0, 0, 0.8);
          border-radius: 5px;
          max-width: 500px;
      }

      .legend i {
          width: 18px;
          height: 18px;
          float: left;
          margin-right: 8px;
          opacity: 0.7;
          clear: left;
      }

      .legend h4 {
        margin-top: 0px;
      }

      .link {
          text-decoration: underline;
          cursor: pointer;
      }
  </style>
</head>

<body>
  <div id="map"></div>
  <script>
    var map = L.map('map', {
      center: [-42, 172],
      zoom: 6,
      //worldCopyJump: true
    })

    var baseMaps = {
      "OSM": L.tileLayer.provider("OpenStreetMap.Mapnik"),
      "CartoDB Positron": L.tileLayer.provider('CartoDB.Positron'),
      "CartoDB Dark Matter": L.tileLayer.provider("CartoDB.DarkMatter"),
      "ESRI WorldImagery": L.tileLayer.provider("Esri.WorldImagery").addTo(map),
      "Google Hybrid": L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
        maxZoom: 20,
        subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
      })
    }

    var overlayMaps = {
    }

    L.control.layers(baseMaps, overlayMaps, { position: "topleft" }).addTo(map);

    var cmap = chroma.scale('RdYlBu').domain([-3, 3])

    map.spin(true);
    $.getJSON("transects_extended.geojson", function (geojson) {
      console.log(geojson)
      const hidden = ["nzd0285", "nzd0284", "nzd0282"]
      geojson.features = geojson.features.filter(f => !hidden.includes(f.properties.site_id))
      console.log(geojson)
      for (var f of geojson.features) {
        for (var c of f.geometry.coordinates) {
          if (c[0] < 0) c[0] += 360
        }
      }
      L.glify.longitudeFirst()
      L.glify.lines({
        map: map,
        data: geojson,
        color: function(index, feature) {
          if (feature.properties.n_points_nonan < 10) {
            return {r:0, g:0, b:0}
          }
          var c = cmap(feature.properties.trend).gl()
          return { r: c[0], g: c[1], b: c[2] };
        },
        click: function (e, feature) {
          $("#plot").remove()
          if (window.popup) map.closePopup(window.popup)
          var p = feature.properties
          if (p.site_id.startsWith("nzd")) {
            var url = `data/${p.site_id}/transect_time_series_tidally_corrected.csv`
          } else {
            var url = `shoreline_data_run6/${p.site_id}/time_series_tidally_corrected.csv`
          }

          window.popup = L.popup({minWidth: 800})
            .setContent(`<b>${p.id}</b><br>
              along_dist: ${p.along_dist?.toFixed(2)}<br>
              along_dist_norm: ${p.along_dist_norm?.toFixed(2)}<br>
              beach_slope: ${p.beach_slope}<br>
              n_points: ${p.n_points}<br>
              n_points_nonan: ${p.n_points_nonan}<br>
              orientation: ${p.orientation?.toFixed(2)}<br>
              trend: ${p.trend?.toFixed(2)} m/year<br>
              R² score: ${p.r2_score?.toFixed(2)} ${p.r2_score < .05 ? " score < 0.05 - linear trend might not be reliable" : ""}<br>
              mae: ${p.mae?.toFixed(2)}<br>
              mse: ${p.mse?.toFixed(2)}<br>
              rmse: ${p.rmse?.toFixed(2)}<br>
              site: ${p.site_id}<br>
              <a href="${url}" target="_blank" class="link">Download time series for ${p.site_id}</a>
              <div id="plot"></div>
            `)
            .setLatLng(e.latlng)
            .addTo(map);
          Papa.parse(url, {
            download: true,
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            complete: function(results) {
              console.log(results)
              var filtered_data = results.data.filter(d => d[p.id])
              var dates = filtered_data.map(d => d.dates)
              var values = filtered_data.map(d => d[p.id])
              var mean = Plotly.d3.mean(values)
              values = values.map(v => v ? v - mean : v)
              console.log(dates,values)
              var min_date = new Date(results.data[0].dates)
              var max_date = new Date(results.data[results.data.length - 1].dates)
              var datediff = (max_date - min_date) / 1000 / 60 / 60 / 24 / 365.25
              var data = [{
                  type: "scatter",
                  mode: "lines+markers",
                  name: "chainage",
                  x: dates,
                  y: values,
                  //line: {color: '#17BECF'}
              }, {
                type: "line",
                x: [min_date, max_date],
                y: [p.intercept - mean, p.trend * datediff + p.intercept - mean],
                name: "trendline"
              }];
              var layout = {
                  title: `Time series for ${p.id}`,
                  xaxis: {
                      title: "Date/Time"
                  },
                  yaxis: {
                      title: "cross-shore change [m]",
                      hoverformat: '.1f'
                  }
              };
              Plotly.newPlot("plot", data, layout);
              var px = map.project(e.latlng);
              console.log(px)
              px.y -= 400;
              map.panTo(map.unproject(px),{animate: true});
            }
          })
        },
        sensitivity: .0001
      });
      map.spin(false);
    });

    var geoSearch = new GeoSearch.GeoSearchControl({
      provider: new GeoSearch.OpenStreetMapProvider(),
      style: 'button',
      autoComplete: true,
      autoCompleteDelay: 250,
      autoClose: true,
      position: "topleft"
    }).addTo(map);

    var legend = L.control({ position: 'bottomright' });

    legend.onAdd = function (map) {
      var div = L.DomUtil.create('div', 'info legend');
      div.innerHTML += "<h4>Trend (m / year)</h4>"
      for (var i = -3; i <= 3; i++) {
        var prefix = ""
        if (i == -3) {
          prefix = "≤ "
        } else if (i == 3) {
          prefix = "≥ "
        }
        div.innerHTML += `<i style="background:${cmap(i).css()}"></i>${prefix + i}<br>`
      }
      div.innerHTML += `<i style="background:black"></i>Uncertain<br>`
      div.innerHTML += `<div id="attribution">Code for shoreline detection provided by K. Vos, M. Harley and K. Splinter (University of New South Wales)<br>
<a href="https://www.unsw.edu.au/research/wrl/our-research/coastsat">https://www.unsw.edu.au/research/wrl/our-research/coastsat</a><br>
For more information about the technique:<br>
<a href="https://doi.org/10.1016/j.envsoft.2019.104528">Vos, K., Splinter, K.D., Harley, M.D., Simmons, J.A. and Turner, I.L., 2019. CoastSat: A Google Earth Engine-enabled Python toolkit to extract shorelines from publicly available satellite imagery. Environmental Modelling & Software, 122, p.104528.</a><br>
      Data for New Zealand reprocessed by Nick Young, using the NIWA Tide API for tidal corrections. Shoreline position is corrected to the MSL. See <a href="https://github.com/UoA-eResearch/CoastSat/blob/main/README.MD">the README</a> for more information.</div>`;
      return div;
    };

    legend.addTo(map);
  </script>
</body>

</html>